<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css"
          integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
    <title>Wind Map</title>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-97010459-1', 'auto');
      ga('send', 'pageview');
    </script>
</head>

<body>
<script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>

<!--
wind.js defines a global variable "weather" that is used in the computation below
This file is generated by the python script that fetch data.
Structure
  weather.Date - When the file was generated
  weather.List - data, thus e.g. weather.List[0].Speed will access the wind speed data for the first element
-->
<script src="data/wind.js"></script>

<h1 style="font-family: Verdana,serif; font-size: 40px; color: #555;">Wind Map</h1>
<hr style="position: absolute; width: 800px">
<br>
<div>
    This page is created using <a href="http://d3js.org">D3</a>.<br>
    It is modelled from Peter Cook's UK <a href="http://prcweb.co.uk/lab/ukwind/"> Wind Map</a>
    and from <a href="http://hint.fm/wind/">Wind</a>.
    The project is available on GitHub as <a href="https://github.com/Wolfrax/Swind">Swind</a>.<br>
    Data from <a href="http://opendata.smhi.se">SMHI</a>.
</div>

<script>
    // Utility conversion functions to/from radians/degrees
    function toRad(deg) { return deg * Math.PI / 180; }
    function toDeg(rad) { return rad * 180 / Math.PI; }

    function lon_lat(coord, speed, dir) {
        // Formula from http://www.movable-type.co.uk/scripts/latlong.html
        // Calculate new lon/lat coordinates based on lon/lat coordinates, speed and direction

        var R = 6371; // Earth's radius in km
        var lon1 = toRad(coord[0]);
        var lat1 = toRad(coord[1]);
        var lat2 = Math.asin(Math.sin(lat1) * Math.cos(speed / R) +
                             Math.cos(lat1) * Math.sin(speed / R) * Math.cos(dir));
        var lon2 = lon1 + Math.atan2(Math.sin(dir) * Math.sin(speed / R) * Math.cos(lat1),
                                     Math.cos(speed / R) - Math.sin(lat1) * Math.sin(lat2));
        return [toDeg(lon2), toDeg(lat2)];
    }

    var width = 1000, height = 600;
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);
    var projection = d3.geo.mercator()
        .center([14.6, 62.1])  // Somewhere in the middle of Sweden, https://sv.wikipedia.org/wiki/Sveriges_geografiska_mittpunkt
        .scale(1000)
        .translate([width / 2, height / 2]);
    var path = d3.geo.path()
        .projection(projection);

    function wind_vector(stn) {
        var wind_speed = stn.Speed;
        var wind_dir = toRad(stn.Dir);
        var start_coord = [stn.Lon, stn.Lat];

        // Using the stations lon/lat coordinates (start_coord) as the starting point for a wind vector
        // we calculate the end coordinates for the wind vector scaling proportionally to speed and direction
        var end_coord = lon_lat(start_coord, 20 * wind_speed, wind_dir);  // 20 is a scaling factor

        // Transform the start and end coordinates according to the selected projection, in our case mercator
        var x0y0 = projection(start_coord);
        var x1y1 = projection(end_coord);

        // Now create a vector object
        return {
            x0: x0y0[0],
            y0: x0y0[1],
            x1: x1y1[0],
            y1: x1y1[1],
            speed: wind_speed,
            dir: wind_dir,
            duration: wind_speed ? 8000 / wind_speed : 0,  /* pre-compute duration, used for animation */
            delay: Math.random() * 1000   /* pre-compute delay, used for animation */
        };
    }  // wind_vector

    // loop through the list of weather station data and transform this into a lsit of wind vectors
    var vectors = [];
    var wind_min = 1000, wind_max = 0;
    var wind_speed_acc = 0, wind_dir_acc = 0;

    for (var i = 0; i < weather.List.length; i++) {
        var vector = wind_vector(weather.List[i]);

        vectors.push(vector);

        // Save some statistics for later display
        wind_min = Math.min(wind_min, vector.speed);
        wind_max = Math.max(wind_max, vector.speed);
        wind_speed_acc += vector.speed;
        wind_dir_acc += toDeg(vector.dir);  // vector.dir is in radians
    }

    var wind_speed_avg = wind_speed_acc / weather.List.length;
    var wind_dir_avg = wind_dir_acc / weather.List.length;

    function wind_animate(line) {
        // Animation of wind on top of the map,
        // in a first step we reset the (x2, y2) coordinates to (x1, y1), d.x0 has the x1 value, d.y0 the y1 value
        // so it becomes a point with opacity set to zero (fully transparent)
        // then we make a linear transition with a specific duration (pre-calculated), set new (x2, y2) values and
        // make line (x1, y1) - (x2, y2) visible (opacity 0.8)
        // then make a new transition for 1 sec (1000ms) and reduce opacity and end with a recursive call to continue
        // animation
        line.attr({ x2: function(d) { return d.x0 },
                    y2: function(d) { return d.y0 } })
            .style('opacity', 0)  // full transparency, not visible
            .transition()
                .ease('linear')
                .duration(function(d) { return d.duration })
                .delay(function(d) { return d.delay })
                .attr({ x2: function(d) { return d.x1},
                        y2: function(d) { return d.y1 } })
                .style('opacity', 0.8)
            .transition()
                .duration(1000)
                .style('opacity', 0.1)
            .each('end', function() { d3.select(this).call(wind_animate) });
    }

    function wind_vector_display(avg_speed, max_speed, avg_dir) {
        var offs = 100;

        var avg_vector = [
            { "x": 0, "y": 0 },
            { "x": avg_speed * Math.cos(wind_dir_avg), "y": avg_speed * Math.sin(wind_dir_avg) } ];

        var my_scale = d3.scale.linear().domain([-max_speed, max_speed]).range([offs, 2 * offs]);
        var lineGen = d3.svg.line()  // generic line generator definition
                        .x(function(d) { return my_scale(d.x); })
                        .y(function(d) { return my_scale(d.y); });

        // Draw a circle scaled by wind_maxspeed, like a unit circle
        svg.append("circle")
            .attr("cx", my_scale(0))
            .attr("cy", my_scale(0))
            .attr("r", (my_scale(max_speed) - offs) / 2)
            .attr('stroke','grey')
            .attr('fill','lightgrey');

        // Now draw x- and y-axis across the circle
        var x_axis = [ {"x": -max_speed, "y": 0}, {"x": max_speed, "y": 0}];
        var y_axis = [ {"x": 0, "y": -max_speed}, {"x": 0, "y": max_speed}];

        // To make the axis come somewhat outside the circle, looks nicer, we rescale max_speed
        // and re-define my_scale using the new max_speed value
        max_speed *= 0.9;
        my_scale = d3.scale.linear().domain([-max_speed, max_speed]).range([offs, 2 * offs]);

        // Now draw x-axis
        svg.append("svg:path")
           .attr("d", lineGen(x_axis))
           .attr("stroke", "grey")
           .attr("stroke-width", 1)
           .attr("fill", "none");

        // The y-axis
        svg.append("svg:path")
           .attr("d", lineGen(y_axis))
           .attr("stroke", "grey")
           .attr("stroke-width", 1)
           .attr("fill", "none");

        // Now we plot the average wind vector using average direction and speed using my_scale
        max_speed /= 0.9; // Re-re-scale maxspeed, back to original value and re-establish my_scale accordingly
        my_scale = d3.scale.linear().domain([-max_speed, max_speed]).range([offs, 2 * offs]);

        svg.append("svg:path")
           .attr("d", lineGen(avg_vector))
           .attr("stroke", "black")
           .attr("stroke-width", 2)
           .attr("fill", "none");

        // Decorate with some text
        svg.append("text")
           .attr("x", my_scale(avg_vector[1].x))
           .attr("y", my_scale(avg_vector[1].y))
           .attr("style", "font-family: Verdana,serif; font-size: 10px; color: #555;")
           .text(Math.round(avg_speed) + "m/s " + Math.round(avg_dir) + "Â°");

        svg.append("text")
           .attr("x", my_scale(max_speed))
           .attr("y", my_scale(0))
           .attr("style", "font-family: Verdana,serif; font-size: 10px; color: #555;")
           .text("Max " + Math.round(max_speed) + "m/s ");
    }

    // Below we generate some text, starting at pre-defined y-position and spacing, x-position is implicitly 0
    svg.append("text")
        .attr("x", 0)  // Hard coded x, y values :-(
        .attr("y", 17)
        .text("Generated at " + weather.Date);

    svg.append("text")
        .attr("x", width - 300)
        .attr("y", height - 75)
        .attr("style", "font-family: Verdana,serif; font-size: 10px; color: #555;")
        .append("a")
        .text("Mats Melander (c)").attr("href", "mailto:mats.melander@gmail.com").style("text-decoration", "underline");

    d3.json("data/swe.json", function (error, se) {
        // We read the vector data in topoJSON format, generated from shapefile (see readme)

        svg.selectAll("county")
            .data(topojson.feature(se, se.objects.subunits).features)
            .enter()
              .append("path")
              .attr("style", "fill: lightgrey")
              .attr("d", path);

        wind_vector_display(wind_speed_avg, wind_max, wind_dir_avg);

        svg.selectAll("wind")        // select all "wind" elements within svg
            .data(vectors)           // bind the data "vectors" to this selection
            .enter()                 // enter for all non-matching elements to the data
              .append("line")        // append "line" to selection (svg element with (x1, y1) to (x2, y2) coord)
              .attr({ x1: function (d) { return d.x0 },
                      y1: function (d) { return d.y0 } })
              .attr("style", "stroke: black")
              .call(wind_animate);
    });

</script>
</body>
</html>